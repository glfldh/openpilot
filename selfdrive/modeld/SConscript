import os
import glob
from pathlib import Path
from SCons.Script import Builder, Action, Scanner, Value

CHUNK_BYTES = 45*1024*1024

Import('env', 'envCython', 'arch', 'cereal', 'messaging', 'common', 'visionipc')
lenv = env.Clone()
lenvCython = envCython.Clone()

libs = [cereal, messaging, visionipc, common, 'capnp', 'kj', 'pthread']
frameworks = []

common_src = [
  "models/commonmodel.cc",
  "transforms/loadyuv.cc",
  "transforms/transform.cc",
]

# OpenCL is a framework on Mac
if arch == "Darwin":
  frameworks += ['OpenCL']
else:
  libs += ['OpenCL']

# Set path definitions
for pathdef, fn in {'TRANSFORM': 'transforms/transform.cl', 'LOADYUV': 'transforms/loadyuv.cl'}.items():
  for xenv in (lenv, lenvCython):
    xenv['CXXFLAGS'].append(f'-D{pathdef}_PATH=\\"{File(fn).abspath}\\"')

# Compile cython
cython_libs = envCython["LIBS"] + libs
commonmodel_lib = lenv.Library('commonmodel', common_src)
lenvCython.Program('models/commonmodel_pyx.so', 'models/commonmodel_pyx.pyx', LIBS=[commonmodel_lib, *cython_libs], FRAMEWORKS=frameworks)
tinygrad_files = sorted(["#"+x for x in glob.glob(env.Dir("#tinygrad_repo").relpath + "/**", recursive=True, root_dir=env.Dir("#").abspath) if 'pycache' not in x])

# Get model metadata
for model_name in ['driving_vision', 'driving_policy', 'dmonitoring_model']:
  fn = File(f"models/{model_name}").abspath
  script_files = [File(Dir("#selfdrive/modeld").File("get_model_metadata.py").abspath)]
  cmd = f'python3 {Dir("#selfdrive/modeld").abspath}/get_model_metadata.py {fn}.onnx'
  lenv.Command(fn + "_metadata.pkl", [fn + ".onnx"] + tinygrad_files + script_files, cmd)

def _define_chunk_commands(parts_txt_path, env, raw_path):
  if not os.path.exists(parts_txt_path):
    return []

  with open(parts_txt_path) as f:
    lines = [x.strip() for x in f.read().splitlines() if x.strip()]

  i = 0
  while i < len(lines) and "=" in lines[i]:
    i += 1

  parts_dir = os.path.dirname(parts_txt_path)
  res = []
  for line in lines[i:]:
    fields = line.split()
    if len(fields) < 2:
      continue
    name = fields[0]
    part_node = env.File(os.path.join(parts_dir, name))

    if not part_node.has_builder():
      env.Command(
        part_node,
        [parts_txt_path],
        f'python3 {env.Dir("#selfdrive/modeld").abspath}/write_part.py $SOURCE {raw_path} $TARGET'
      )
      env.Requires(part_node, raw_path)

    res.append(part_node)
  return res

def _parts_scanner(node, env, path):
  if not node.exists():
    return []
  raw_path = node.sources[0].get_path() if getattr(node, 'sources', None) else ''
  return _define_chunk_commands(node.abspath, env, raw_path)


lenv['BUILDERS']['EnsureParts'] = Builder(
  action=Action('python3 -c "open(\\"$TARGET\\", \\"w\\").write(\\"ok\\")"'),
  source_scanner=Scanner(_parts_scanner),
)

split_pickle_files = [File(f).abspath for f in ['write_part.py', 'make_parts.py', 'external_pickle.py']]

def tg_compile(flags, model_name):
  pythonpath_string = 'PYTHONPATH="${PYTHONPATH}:' + env.Dir("#tinygrad_repo").abspath + '"'
  fn = File(f"models/{model_name}").abspath
  out = fn + "_tinygrad.pkl"
  raw = out + ".raw"
  stamp = out + ".parts.stamp"
  parts_txt = out + ".parts"

  lenv.Command(
    raw,
    [fn + ".onnx"] + tinygrad_files,
    f'{pythonpath_string} {flags} python3 {Dir("#tinygrad_repo").abspath}/examples/openpilot/compile3.py {fn}.onnx {raw}'
  )

  _define_chunk_commands(parts_txt, lenv, raw)

  lenv.Command(
    parts_txt,
    [raw] + split_pickle_files + [Value(str(CHUNK_BYTES))],
    f'python3 {Dir("#selfdrive/modeld").abspath}/make_parts.py {raw} {parts_txt} {Path(out).name} {CHUNK_BYTES}'
  )

  node = lenv.EnsureParts(stamp, parts_txt)

  lenv.Clean(node, Glob(out + ".data-*"))
  lenv.Clean(node, raw)
  lenv.Clean(node, parts_txt)
  lenv.Clean(node, stamp)

  return node

# Compile small models
for model_name in ['driving_vision', 'driving_policy', 'dmonitoring_model']:
  flags = {
    'larch64': 'DEV=QCOM FLOAT16=1 NOLOCALS=1 IMAGE=2 JIT_BATCH_SIZE=0',
    'Darwin': f'DEV=CPU HOME={os.path.expanduser("~")}', # tinygrad calls brew which needs a $HOME in the env
  }.get(arch, 'DEV=CPU CPU_LLVM=1')
  tg_compile(flags, model_name)

# Compile BIG model if USB GPU is available
if "USBGPU" in os.environ:
  import subprocess
  # because tg doesn't support multi-process
  devs = subprocess.check_output('python3 -c "from tinygrad import Device; print(list(Device.get_available_devices()))"', shell=True, cwd=env.Dir('#').abspath)
  if b"AMD" in devs:
    print("USB GPU detected... building")
    flags = "DEV=AMD AMD_IFACE=USB AMD_LLVM=1 NOLOCALS=0 IMAGE=0"
    bp = tg_compile(flags, "big_driving_policy")
    bv = tg_compile(flags, "big_driving_vision")
    lenv.SideEffect('lock', [bp, bv])  # tg doesn't support multi-process so build serially
  else:
    print("USB GPU not detected... skipping")

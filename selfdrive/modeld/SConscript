import os
import glob

Import('env', 'arch')
lenv = env.Clone()

tinygrad_root = env.Dir("#").abspath
tinygrad_files = ["#"+x for x in glob.glob(env.Dir("#tinygrad_repo").relpath + "/**", recursive=True, root_dir=tinygrad_root)
                  if 'pycache' not in x and os.path.isfile(os.path.join(tinygrad_root, x))]

from openpilot.common.file_chunker import chunk_file, get_num_chunks

# Get model metadata
for model_name in ['driving_vision', 'driving_policy', 'dmonitoring_model']:
  fn = File(f"models/{model_name}").abspath
  script_files = [File(Dir("#selfdrive/modeld").File("get_model_metadata.py").abspath)]
  cmd = f'python3 {Dir("#selfdrive/modeld").abspath}/get_model_metadata.py {fn}.onnx'
  lenv.Command(fn + "_metadata.pkl", [fn + ".onnx"] + tinygrad_files + script_files, cmd)

# compile warp
# THREADS=0 is need to prevent bug: https://github.com/tinygrad/tinygrad/issues/14689
tg_flags = {
    'larch64': 'DEV=QCOM FLOAT16=1 NOLOCALS=1 JIT_BATCH_SIZE=0',
    'Darwin': f'DEV=CPU THREADS=0 HOME={os.path.expanduser("~")}', # tinygrad calls brew which needs a $HOME in the env
}.get(arch, 'DEV=CPU CPU_LLVM=1 THREADS=0')
image_flag = {
     'larch64': 'IMAGE=2',
}.get(arch, 'IMAGE=0')
script_files = [File(Dir("#selfdrive/modeld").File("compile_warp.py").abspath), File("#common/file_chunker.py")]
compile_warp_cmd = f'{tg_flags} python3 {Dir("#selfdrive/modeld").abspath}/compile_warp.py '
from openpilot.common.transformations.camera import _ar_ox_fisheye, _os_fisheye
warp_targets = []
for cam in [_ar_ox_fisheye, _os_fisheye]:
  w, h = cam.width, cam.height
  warp_targets += [File(f"models/warp_{w}x{h}_tinygrad.pkl").abspath, File(f"models/dm_warp_{w}x{h}_tinygrad.pkl").abspath]
def chunk_warps(target, source, env):
  for t in warp_targets:
    chunk_file(t, 1)   # writes t.parts + t.chunk00 and deletes t
lenv.Command(
  [t + ".parts" for t in warp_targets] + [t + ".chunk00" for t in warp_targets],
  tinygrad_files + script_files,
  [compile_warp_cmd, chunk_warps],
)

def tg_compile(flags, model_name):
  pythonpath_string = 'PYTHONPATH="${PYTHONPATH}:' + env.Dir("#tinygrad_repo").abspath + '"'
  fn = File(f"models/{model_name}").abspath
  pkl = fn + "_tinygrad.pkl"
  onnx_path = fn + ".onnx"
  num_chunks = get_num_chunks(os.path.getsize(onnx_path))
  def do_chunk(target, source, env):
    chunk_file(pkl, num_chunks)  # writes pkl.parts + pkl.chunkXX and deletes pkl

  return lenv.Command(
    [f"{pkl}.parts"] + [f"{pkl}.chunk{i:02d}" for i in range(num_chunks)],
    [onnx_path] + tinygrad_files + [File("#openpilot/common/file_chunker.py")],
    [
      f'{pythonpath_string} {flags} {image_flag} python3 {Dir("#tinygrad_repo").abspath}/examples/openpilot/compile3.py {fn}.onnx {pkl}',
      do_chunk,
    ],
  )


# Compile small models
for model_name in ['driving_vision', 'driving_policy', 'dmonitoring_model']:
  tg_compile(tg_flags, model_name)

# Compile BIG model if USB GPU is available
if "USBGPU" in os.environ:
  import subprocess
  # because tg doesn't support multi-process
  devs = subprocess.check_output('python3 -c "from tinygrad import Device; print(list(Device.get_available_devices()))"', shell=True, cwd=env.Dir('#').abspath)
  if b"AMD" in devs:
    print("USB GPU detected... building")
    flags = "DEV=AMD AMD_IFACE=USB AMD_LLVM=1 NOLOCALS=0 IMAGE=0"
    bp = tg_compile(flags, "big_driving_policy")
    bv = tg_compile(flags, "big_driving_vision")
    lenv.SideEffect('lock', [bp, bv])  # tg doesn't support multi-process so build serially
  else:
    print("USB GPU not detected... skipping")
